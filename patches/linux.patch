# ath
# ===

--- drivers/net/wireless/ath/Makefile
+++ drivers/net/wireless/ath/Makefile
@@ -22,3 +22,9 @@
 ath-$(CONFIG_ATH_TRACEPOINTS) += trace.o

 CFLAGS_trace.o := -I$(src)
+
+all:
+	$(MAKE) -C /lib/modules/$(shell uname -r)/build M=$(shell pwd) modules
+
+clean:
+	$(MAKE) -C /lib/modules/$(shell uname -r)/build M=$(shell pwd) clean

--- drivers/net/wireless/ath/regd.c
+++ drivers/net/wireless/ath/regd.c
@@ -45,9 +45,9 @@ static int __ath_regd_init(struct ath_regulatory *reg);
 /* We allow IBSS on these on a case by case basis by regulatory domain */
 #define ATH_5GHZ_5150_5350	REG_RULE(5150-10, 5350+10, 80, 0, 30,\
 					 NL80211_RRF_NO_IR)
-#define ATH_5GHZ_5470_5850	REG_RULE(5470-10, 5850+10, 80, 0, 30,\
+#define ATH_5GHZ_5470_5925	REG_RULE(5470-10, 5925+10, 80, 0, 30,\
 					 NL80211_RRF_NO_IR)
-#define ATH_5GHZ_5725_5850	REG_RULE(5725-10, 5850+10, 80, 0, 30,\
+#define ATH_5GHZ_5725_5925	REG_RULE(5725-10, 5925+10, 80, 0, 30,\
 					 NL80211_RRF_NO_IR)
 
 #define ATH_2GHZ_ALL		ATH_2GHZ_CH01_11, \
@@ -55,11 +55,11 @@ static int __ath_regd_init(struct ath_regulatory *reg);
 				ATH_2GHZ_CH14
 
 #define ATH_5GHZ_ALL		ATH_5GHZ_5150_5350, \
-				ATH_5GHZ_5470_5850
+				ATH_5GHZ_5470_5925
 
 /* This one skips what we call "mid band" */
 #define ATH_5GHZ_NO_MIDBAND	ATH_5GHZ_5150_5350, \
-				ATH_5GHZ_5725_5850
+				ATH_5GHZ_5725_5925
 
 /* Can be used for:
  * 0x60, 0x61, 0x62 */

#--- drivers/net/wireless/ath/regd.c
#+++ drivers/net/wireless/ath/regd.c
#@@ -639,8 +639,7 @@
# 	const struct ieee80211_regdomain *regd;
# 
# 	wiphy->reg_notifier = reg_notifier;
#-	wiphy->regulatory_flags |= REGULATORY_STRICT_REG |
#-				   REGULATORY_CUSTOM_REG;
#+	wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;
# 
# 	if (ath_is_world_regd(reg)) {
# 		/*
#@@ -660,7 +659,7 @@
# 
# 	wiphy_apply_custom_regulatory(wiphy, regd);
# 	ath_reg_apply_radar_flags(wiphy, reg);
#-	ath_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER, reg);
#+	ath_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_USER, reg);
# 	return 0;
# }

# ath9k
# =====

--- drivers/net/wireless/ath/ath9k/Makefile
+++ drivers/net/wireless/ath/ath9k/Makefile
@@ -79,3 +79,9 @@ ath9k_htc-y +=	htc_hst.o \
 obj-$(CONFIG_ATH9K_HTC) += ath9k_htc.o

 obj-$(CONFIG_ATH9K_PCI_NO_EEPROM) += ath9k_pci_owl_loader.o
+
+all:
+	$(MAKE) -C /lib/modules/$(shell uname -r)/build M=$(shell pwd) modules
+
+clean:
+	$(MAKE) -C /lib/modules/$(shell uname -r)/build M=$(shell pwd) clean

--- drivers/net/wireless/ath/ath9k/ani.c
+++ drivers/net/wireless/ath/ath9k/ani.c
@@ -326,6 +326,7 @@
 
 	if (is_scanning ||
 	    (ah->opmode != NL80211_IFTYPE_STATION &&
+	     ah->opmode != NL80211_IFTYPE_OCB &&
 	     ah->opmode != NL80211_IFTYPE_ADHOC)) {
 		/*
 		 * If we're scanning or in AP mode, the defaults (ini)
     
--- drivers/net/wireless/ath/ath9k/common-init.c
+++ drivers/net/wireless/ath/ath9k/common-init.c
@@ -86,6 +86,15 @@
 	CHAN5G(5785, 35), /* Channel 157 */
 	CHAN5G(5805, 36), /* Channel 161 */
 	CHAN5G(5825, 37), /* Channel 165 */
+
+	/* ETSI EN 302 663 */
+	CHAN5G(5860, 38), /* Channel 172, ITS-G5B G5-SCH4 */
+	CHAN5G(5870, 39), /* Channel 174, ITS-G5B G5-SCH3 */
+	CHAN5G(5880, 40), /* Channel 176, ITS-G5A G5-SCH1 */
+	CHAN5G(5890, 41), /* Channel 178, ITS-G5A G5-SCH2 */
+	CHAN5G(5900, 42), /* Channel 180, ITS-G5A G5-CCH */
+	CHAN5G(5910, 43), /* Channel 182, ITS-G5D G5-SCH5 */
+	CHAN5G(5920, 44), /* Channel 184, ITS-G5D G5-SCH6 */
 };
 
 /* Atheros hardware rate code addition for short preamble */

--- drivers/net/wireless/ath/ath9k/hw.h
+++ drivers/net/wireless/ath/ath9k/hw.h
@@ -73,7 +73,7 @@
 
 #define ATH9K_RSSI_BAD			-128
 
-#define ATH9K_NUM_CHANNELS	38
+#define ATH9K_NUM_CHANNELS	45
 
 /* Register read/write primitives */
 #define REG_WRITE(_ah, _reg, _val) \

# ath10k
# ======

# todo: once we get this working, check which changes are really
# required

--- drivers/net/wireless/ath/ath10k/core.h
+++ drivers/net/wireless/ath/ath10k/core.h
@@ -37,8 +37,8 @@
 #define WMI_READY_TIMEOUT (5 * HZ)
 #define ATH10K_FLUSH_TIMEOUT_HZ (5 * HZ)
 #define ATH10K_CONNECTION_LOSS_HZ (3 * HZ)
-#define ATH10K_NUM_CHANS 41
-#define ATH10K_MAX_5G_CHAN 173
+#define ATH10K_NUM_CHANS 47
+#define ATH10K_MAX_5G_CHAN 184
 
 /* Antenna noise floor */
 #define ATH10K_DEFAULT_NOISE_FLOOR -95

--- drivers/net/wireless/ath/ath10k/mac.c
+++ drivers/net/wireless/ath/ath10k/mac.c
@@ -5276,6 +5276,7 @@
 					(ar, WMI_VDEV_SUBTYPE_P2P_CLIENT);
 		break;
 	case NL80211_IFTYPE_ADHOC:
+	case NL80211_IFTYPE_OCB:
 		arvif->vdev_type = WMI_VDEV_TYPE_IBSS;
 		break;
 	case NL80211_IFTYPE_MESH_POINT:
@@ -5331,6 +5332,12 @@
 	 */
 	if (vif->type == NL80211_IFTYPE_ADHOC ||
 	    vif->type == NL80211_IFTYPE_MESH_POINT ||
+
+	    // We reuse the ad hoc mode for OCB, so we better also allocate
+	    // this buffer. However, in OCB mode, we should never rx or tx
+	    // beacons.
+	    vif->type == NL80211_IFTYPE_OCB ||
+
 	    vif->type == NL80211_IFTYPE_AP) {
 		arvif->beacon_buf = dma_alloc_coherent(ar->dev,
 						       IEEE80211_MAX_FRAME_LEN,
@@ -5761,7 +5768,7 @@
 
 	mutex_lock(&ar->conf_mutex);
 
-	if (changed & BSS_CHANGED_IBSS)
+	if (changed & (BSS_CHANGED_IBSS | BSS_CHANGED_OCB)) /* ? */
 		ath10k_control_ibss(arvif, info, vif->addr);
 
 	if (changed & BSS_CHANGED_BEACON_INT) {
@@ -6745,7 +6752,11 @@
 		   new_state == IEEE80211_STA_ASSOC &&
 		   (vif->type == NL80211_IFTYPE_AP ||
 		    vif->type == NL80211_IFTYPE_MESH_POINT ||
-		    vif->type == NL80211_IFTYPE_ADHOC)) {
+		    vif->type == NL80211_IFTYPE_ADHOC ||
+
+		    // We reuse the ad hoc mode for OCB, so we better play along
+		    // here as well. However, in OCB mode, there is no association.
+		    vif->type == NL80211_IFTYPE_OCB)) {
 		/*
 		 * New association.
 		 */
@@ -6781,7 +6792,11 @@
 		    new_state == IEEE80211_STA_AUTH &&
 		    (vif->type == NL80211_IFTYPE_AP ||
 		     vif->type == NL80211_IFTYPE_MESH_POINT ||
-		     vif->type == NL80211_IFTYPE_ADHOC)) {
+		     vif->type == NL80211_IFTYPE_ADHOC ||
+
+		     // We reuse the ad hoc mode for OCB, so we better play along
+		     // here as well. However, in OCB mode, there is no association.
+		     vif->type == NL80211_IFTYPE_OCB)) {
 		/*
 		 * Disassociation.
 		 */
@@ -8389,7 +8404,16 @@
 	CHAN5G(161, 5805, 0),
 	CHAN5G(165, 5825, 0),
 	CHAN5G(169, 5845, 0),
-	CHAN5G(173, 5865, 0),
+
+
+	/* ETSI EN 302 663 */
+	CHAN5G(172, 5860, 0), /* Channel 172, ITS-G5B G5-SCH4 */
+	CHAN5G(174, 5870, 0), /* Channel 174, ITS-G5B G5-SCH3 */
+	CHAN5G(176, 5880, 0), /* Channel 176, ITS-G5A G5-SCH1 */
+	CHAN5G(178, 5890, 0), /* Channel 178, ITS-G5A G5-SCH2 */
+	CHAN5G(180, 5900, 0), /* Channel 180, ITS-G5A G5-CCH */
+	CHAN5G(182, 5910, 0), /* Channel 182, ITS-G5D G5-SCH5 */
+	CHAN5G(184, 5920, 0), /* Channel 184, ITS-G5D G5-SCH6 */
 	/* If you add more, you may need to change ATH10K_MAX_5G_CHAN */
 	/* And you will definitely need to change ATH10K_NUM_CHANS in core.h */
 };
@@ -8501,7 +8525,8 @@
 			 BIT(NL80211_IFTYPE_MESH_POINT) |
 #endif
 			 BIT(NL80211_IFTYPE_P2P_CLIENT) |
-			 BIT(NL80211_IFTYPE_P2P_GO),
+			 BIT(NL80211_IFTYPE_P2P_GO) |
+			 BIT(NL80211_IFTYPE_OCB),
 	},
 	{
 		.max = 1,
@@ -8541,6 +8566,10 @@
 		.max = 1,
 		.types = BIT(NL80211_IFTYPE_ADHOC),
 	},
+	{
+		.max = 1,
+		.types = BIT(NL80211_IFTYPE_OCB),
+	},
 };
 
 /* FIXME: This is not thouroughly tested. These combinations may over- or
@@ -8851,7 +8880,11 @@
 	ar->hw->wiphy->interface_modes =
 		BIT(NL80211_IFTYPE_STATION) |
 		BIT(NL80211_IFTYPE_AP) |
-		BIT(NL80211_IFTYPE_MESH_POINT);
+		BIT(NL80211_IFTYPE_MESH_POINT) |
+		BIT(NL80211_IFTYPE_OCB);
+
+	// support 10 MHz channel width for OCB
+	ar->hw->wiphy->flags |= NL80211_CHAN_WIDTH_10;

 	ar->hw->wiphy->available_antennas_rx = ar->cfg_rx_chainmask;
 	ar->hw->wiphy->available_antennas_tx = ar->cfg_tx_chainmask;
--- drivers/net/wireless/ath/ath10k/Makefile
+++ drivers/net/wireless/ath/ath10k/Makefile
@@ -42,3 +42,9 @@
 
 # for tracing framework to find trace.h
 CFLAGS_trace.o := -I$(src)
+
+all:
+	$(MAKE) -C /lib/modules/$(shell uname -r)/build M=$(shell pwd) modules
+
+clean:
+	$(MAKE) -C /lib/modules/$(shell uname -r)/build M=$(shell pwd) clean

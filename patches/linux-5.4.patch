# ath
# ===

--- drivers/net/wireless/ath/Makefile
+++ drivers/net/wireless/ath/Makefile
@@ -22,3 +22,9 @@
 ath-$(CONFIG_ATH_TRACEPOINTS) += trace.o

 CFLAGS_trace.o := -I$(src)
+
+all:
+	$(MAKE) -C /lib/modules/$(shell uname -r)/build M=$(shell pwd) modules
+
+clean:
+	$(MAKE) -C /lib/modules/$(shell uname -r)/build M=$(shell pwd) clean

--- drivers/net/wireless/ath/regd.c
+++ drivers/net/wireless/ath/regd.c
@@ -45,9 +45,9 @@ static int __ath_regd_init(struct ath_regulatory *reg);
 /* We allow IBSS on these on a case by case basis by regulatory domain */
 #define ATH_5GHZ_5150_5350	REG_RULE(5150-10, 5350+10, 80, 0, 30,\
 					 NL80211_RRF_NO_IR)
-#define ATH_5GHZ_5470_5850	REG_RULE(5470-10, 5850+10, 80, 0, 30,\
+#define ATH_5GHZ_5470_5925	REG_RULE(5470-10, 5925+10, 80, 0, 30,\
 					 NL80211_RRF_NO_IR)
-#define ATH_5GHZ_5725_5850	REG_RULE(5725-10, 5850+10, 80, 0, 30,\
+#define ATH_5GHZ_5725_5925	REG_RULE(5725-10, 5925+10, 80, 0, 30,\
 					 NL80211_RRF_NO_IR)
 
 #define ATH_2GHZ_ALL		ATH_2GHZ_CH01_11, \
@@ -55,11 +55,11 @@ static int __ath_regd_init(struct ath_regulatory *reg);
 				ATH_2GHZ_CH14
 
 #define ATH_5GHZ_ALL		ATH_5GHZ_5150_5350, \
-				ATH_5GHZ_5470_5850
+				ATH_5GHZ_5470_5925
 
 /* This one skips what we call "mid band" */
 #define ATH_5GHZ_NO_MIDBAND	ATH_5GHZ_5150_5350, \
-				ATH_5GHZ_5725_5850
+				ATH_5GHZ_5725_5925
 
 /* Can be used for:
  * 0x60, 0x61, 0x62 */

#--- drivers/net/wireless/ath/regd.c
#+++ drivers/net/wireless/ath/regd.c
#@@ -639,8 +639,7 @@
# 	const struct ieee80211_regdomain *regd;
# 
# 	wiphy->reg_notifier = reg_notifier;
#-	wiphy->regulatory_flags |= REGULATORY_STRICT_REG |
#-				   REGULATORY_CUSTOM_REG;
#+	wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;
# 
# 	if (ath_is_world_regd(reg)) {
# 		/*
#@@ -660,7 +659,7 @@
# 
# 	wiphy_apply_custom_regulatory(wiphy, regd);
# 	ath_reg_apply_radar_flags(wiphy, reg);
#-	ath_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER, reg);
#+	ath_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_USER, reg);
# 	return 0;
# }

# ath9k
# =====

--- drivers/net/wireless/ath/ath9k/Makefile
+++ drivers/net/wireless/ath/ath9k/Makefile
@@ -79,3 +79,9 @@ ath9k_htc-y +=	htc_hst.o \
 obj-$(CONFIG_ATH9K_HTC) += ath9k_htc.o

 obj-$(CONFIG_ATH9K_PCI_NO_EEPROM) += ath9k_pci_owl_loader.o
+
+all:
+	$(MAKE) -C /lib/modules/$(shell uname -r)/build M=$(shell pwd) modules
+
+clean:
+	$(MAKE) -C /lib/modules/$(shell uname -r)/build M=$(shell pwd) clean

--- drivers/net/wireless/ath/ath9k/ani.c
+++ drivers/net/wireless/ath/ath9k/ani.c
@@ -326,6 +326,7 @@
 
 	if (is_scanning ||
 	    (ah->opmode != NL80211_IFTYPE_STATION &&
+	     ah->opmode != NL80211_IFTYPE_OCB &&
 	     ah->opmode != NL80211_IFTYPE_ADHOC)) {
 		/*
 		 * If we're scanning or in AP mode, the defaults (ini)
     
--- drivers/net/wireless/ath/ath9k/common-init.c
+++ drivers/net/wireless/ath/ath9k/common-init.c
@@ -86,6 +86,15 @@
 	CHAN5G(5785, 35), /* Channel 157 */
 	CHAN5G(5805, 36), /* Channel 161 */
 	CHAN5G(5825, 37), /* Channel 165 */
+
+	/* ETSI EN 302 663 */
+	CHAN5G(5860, 38), /* Channel 172, ITS-G5B G5-SCH4 */
+	CHAN5G(5870, 39), /* Channel 174, ITS-G5B G5-SCH3 */
+	CHAN5G(5880, 40), /* Channel 176, ITS-G5A G5-SCH1 */
+	CHAN5G(5890, 41), /* Channel 178, ITS-G5A G5-SCH2 */
+	CHAN5G(5900, 42), /* Channel 180, ITS-G5A G5-CCH */
+	CHAN5G(5910, 43), /* Channel 182, ITS-G5D G5-SCH5 */
+	CHAN5G(5920, 44), /* Channel 184, ITS-G5D G5-SCH6 */
 };
 
 /* Atheros hardware rate code addition for short preamble */

--- drivers/net/wireless/ath/ath9k/hw.h
+++ drivers/net/wireless/ath/ath9k/hw.h
@@ -73,7 +73,7 @@
 
 #define ATH9K_RSSI_BAD			-128
 
-#define ATH9K_NUM_CHANNELS	38
+#define ATH9K_NUM_CHANNELS	45
 
 /* Register read/write primitives */
 #define REG_WRITE(_ah, _reg, _val) \

# ath10k
# ======

# todo: once we get this working, check which changes are really
# required

--- drivers/net/wireless/ath/ath10k/core.h
+++ drivers/net/wireless/ath/ath10k/core.h
@@ -37,8 +37,8 @@
 #define WMI_READY_TIMEOUT (5 * HZ)
 #define ATH10K_FLUSH_TIMEOUT_HZ (5 * HZ)
 #define ATH10K_CONNECTION_LOSS_HZ (3 * HZ)
-#define ATH10K_NUM_CHANS 41
-#define ATH10K_MAX_5G_CHAN 173
+#define ATH10K_NUM_CHANS 47
+#define ATH10K_MAX_5G_CHAN 184
 
 /* Antenna noise floor */
 #define ATH10K_DEFAULT_NOISE_FLOOR -95

--- drivers/net/wireless/ath/ath10k/Makefile
+++ drivers/net/wireless/ath/ath10k/Makefile
@@ -42,3 +42,9 @@
 
 # for tracing framework to find trace.h
 CFLAGS_trace.o := -I$(src)
+
+all:
+	$(MAKE) -C /lib/modules/$(shell uname -r)/build M=$(shell pwd) modules
+
+clean:
+	$(MAKE) -C /lib/modules/$(shell uname -r)/build M=$(shell pwd) clean

--- drivers/net/wireless/ath/ath10k/wmi.c
+++ drivers/net/wireless/ath/ath10k/wmi.c
@@ -1713,6 +1713,10 @@
 		flags |= WMI_CHAN_FLAG_HT40_PLUS;
 	if (arg->chan_radar)
 		flags |= WMI_CHAN_FLAG_DFS;
+	if (arg->rate_half)
+		flags |= WMI_CHAN_FLAG_HALF;
+	if (arg->rate_quarter)
+		flags |= WMI_CHAN_FLAG_QUARTER;
 
 	ch->mhz = __cpu_to_le32(arg->freq);
 	ch->band_center_freq1 = __cpu_to_le32(arg->band_center_freq1);
--- drivers/net/wireless/ath/ath10k/wmi.h
+++ drivers/net/wireless/ath/ath10k/wmi.h
@@ -2070,6 +2070,8 @@
 	bool allow_vht;
 	bool ht40plus;
 	bool chan_radar;
+	bool rate_half;
+	bool rate_quarter;
 	/* note: power unit is 0.5 dBm */
 	u32 min_power;
 	u32 max_power;
@@ -2091,6 +2093,8 @@
 #define WMI_CHAN_FLAG_DFS            (1 << 10)
 #define WMI_CHAN_FLAG_ALLOW_HT       (1 << 11)
 #define WMI_CHAN_FLAG_ALLOW_VHT      (1 << 12)
+#define WMI_CHAN_FLAG_QUARTER        (1 << 13)
+#define WMI_CHAN_FLAG_HALF           (1 << 14)
 
 /* Indicate reason for channel switch */
 #define WMI_CHANNEL_CHANGE_CAUSE_CSA (1 << 13)
--- drivers/net/wireless/ath/ath10k/mac.c
+++ drivers/net/wireless/ath/ath10k/mac.c
@@ -580,6 +580,8 @@
 	case NL80211_BAND_5GHZ:
 		switch (chandef->width) {
 		case NL80211_CHAN_WIDTH_20_NOHT:
+		case NL80211_CHAN_WIDTH_5:
+		case NL80211_CHAN_WIDTH_10:
 			phymode = MODE_11A;
 			break;
 		case NL80211_CHAN_WIDTH_20:
@@ -597,10 +599,6 @@
 		case NL80211_CHAN_WIDTH_80P80:
 			phymode = MODE_11AC_VHT80_80;
 			break;
-		case NL80211_CHAN_WIDTH_5:
-		case NL80211_CHAN_WIDTH_10:
-			phymode = MODE_UNKNOWN;
-			break;
 		}
 		break;
 	default:
@@ -1039,6 +1037,12 @@
 	arg.channel.chan_radar =
 			!!(channel->flags & IEEE80211_CHAN_RADAR);
 
+	if (chandef->width == NL80211_CHAN_WIDTH_10) {
+		arg.channel.rate_half = 1;
+	} else if (chandef->width == NL80211_CHAN_WIDTH_5) {
+		arg.channel.rate_quarter = 1;
+	}
+
 	arg.channel.min_power = 0;
 	arg.channel.max_power = channel->max_power * 2;
 	arg.channel.max_reg_power = channel->max_reg_power * 2;
@@ -1490,6 +1494,12 @@
 	arg.channel.max_reg_power = chandef->chan->max_reg_power * 2;
 	arg.channel.max_antenna_gain = chandef->chan->max_antenna_gain * 2;
 
+	if (chandef->width == NL80211_CHAN_WIDTH_10) {
+		arg.channel.rate_half = 1;
+	} else if (chandef->width == NL80211_CHAN_WIDTH_5) {
+		arg.channel.rate_quarter = 1;
+	}
+
 	if (arvif->vdev_type == WMI_VDEV_TYPE_AP) {
 		arg.ssid = arvif->u.ap.ssid;
 		arg.ssid_len = arvif->u.ap.ssid_len;
@@ -5290,6 +5300,7 @@
 					(ar, WMI_VDEV_SUBTYPE_P2P_CLIENT);
 		break;
 	case NL80211_IFTYPE_ADHOC:
+	case NL80211_IFTYPE_OCB:
 		arvif->vdev_type = WMI_VDEV_TYPE_IBSS;
 		break;
 	case NL80211_IFTYPE_MESH_POINT:
@@ -5345,6 +5356,12 @@
 	 */
 	if (vif->type == NL80211_IFTYPE_ADHOC ||
 	    vif->type == NL80211_IFTYPE_MESH_POINT ||
+
+	    // We reuse the ad hoc mode for OCB, so we better also allocate
+	    // this buffer. However, in OCB mode, we should never rx or tx
+	    // beacons.
+	    vif->type == NL80211_IFTYPE_OCB ||
+
 	    vif->type == NL80211_IFTYPE_AP) {
 		arvif->beacon_buf = dma_alloc_coherent(ar->dev,
 						       IEEE80211_MAX_FRAME_LEN,
@@ -5775,7 +5792,7 @@
 
 	mutex_lock(&ar->conf_mutex);
 
-	if (changed & BSS_CHANGED_IBSS)
+	if (changed & (BSS_CHANGED_IBSS | BSS_CHANGED_OCB)) /* ? */
 		ath10k_control_ibss(arvif, info, vif->addr);
 
 	if (changed & BSS_CHANGED_BEACON_INT) {
@@ -6765,7 +6782,11 @@
 		   new_state == IEEE80211_STA_ASSOC &&
 		   (vif->type == NL80211_IFTYPE_AP ||
 		    vif->type == NL80211_IFTYPE_MESH_POINT ||
-		    vif->type == NL80211_IFTYPE_ADHOC)) {
+		    vif->type == NL80211_IFTYPE_ADHOC ||
+
+		    // We reuse the ad hoc mode for OCB, so we better play along
+		    // here as well. However, in OCB mode, there is no association.
+		    vif->type == NL80211_IFTYPE_OCB)) {
 		/*
 		 * New association.
 		 */
@@ -6801,7 +6822,11 @@
 		    new_state == IEEE80211_STA_AUTH &&
 		    (vif->type == NL80211_IFTYPE_AP ||
 		     vif->type == NL80211_IFTYPE_MESH_POINT ||
-		     vif->type == NL80211_IFTYPE_ADHOC)) {
+		     vif->type == NL80211_IFTYPE_ADHOC ||
+
+		     // We reuse the ad hoc mode for OCB, so we better play along
+		     // here as well. However, in OCB mode, there is no association.
+		     vif->type == NL80211_IFTYPE_OCB)) {
 		/*
 		 * Disassociation.
 		 */
@@ -8410,7 +8435,16 @@
 	CHAN5G(161, 5805, 0),
 	CHAN5G(165, 5825, 0),
 	CHAN5G(169, 5845, 0),
-	CHAN5G(173, 5865, 0),
+
+
+	/* ETSI EN 302 663 */
+	CHAN5G(172, 5860, 0), /* Channel 172, ITS-G5B G5-SCH4 */
+	CHAN5G(174, 5870, 0), /* Channel 174, ITS-G5B G5-SCH3 */
+	CHAN5G(176, 5880, 0), /* Channel 176, ITS-G5A G5-SCH1 */
+	CHAN5G(178, 5890, 0), /* Channel 178, ITS-G5A G5-SCH2 */
+	CHAN5G(180, 5900, 0), /* Channel 180, ITS-G5A G5-CCH */
+	CHAN5G(182, 5910, 0), /* Channel 182, ITS-G5D G5-SCH5 */
+	CHAN5G(184, 5920, 0), /* Channel 184, ITS-G5D G5-SCH6 */
 	/* If you add more, you may need to change ATH10K_MAX_5G_CHAN */
 	/* And you will definitely need to change ATH10K_NUM_CHANS in core.h */
 };
@@ -8522,7 +8556,8 @@
 			 BIT(NL80211_IFTYPE_MESH_POINT) |
 #endif
 			 BIT(NL80211_IFTYPE_P2P_CLIENT) |
-			 BIT(NL80211_IFTYPE_P2P_GO),
+			 BIT(NL80211_IFTYPE_P2P_GO) |
+			 BIT(NL80211_IFTYPE_OCB),
 	},
 	{
 		.max = 1,
@@ -8562,6 +8597,10 @@
 		.max = 1,
 		.types = BIT(NL80211_IFTYPE_ADHOC),
 	},
+	{
+		.max = 1,
+		.types = BIT(NL80211_IFTYPE_OCB),
+	},
 };
 
 /* FIXME: This is not thouroughly tested. These combinations may over- or
@@ -8872,7 +8911,11 @@
 	ar->hw->wiphy->interface_modes =
 		BIT(NL80211_IFTYPE_STATION) |
 		BIT(NL80211_IFTYPE_AP) |
-		BIT(NL80211_IFTYPE_MESH_POINT);
+		BIT(NL80211_IFTYPE_MESH_POINT) |
+		BIT(NL80211_IFTYPE_OCB);
+
+	// support 10 MHz channel width for OCB
+	ar->hw->wiphy->flags |= NL80211_CHAN_WIDTH_10;

 	ar->hw->wiphy->available_antennas_rx = ar->cfg_rx_chainmask;
 	ar->hw->wiphy->available_antennas_tx = ar->cfg_tx_chainmask;
@@ -8965,6 +9008,7 @@
 
 	ar->hw->wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
 	ar->hw->wiphy->flags |= WIPHY_FLAG_HAS_CHANNEL_SWITCH;
+	ar->hw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_5_10_MHZ;
 	ar->hw->wiphy->max_remain_on_channel_duration = 5000;
 
 	ar->hw->wiphy->flags |= WIPHY_FLAG_AP_UAPSD;
